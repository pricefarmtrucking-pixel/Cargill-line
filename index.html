<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FarmPro • Multi-Lane Map & Rate Calculator</title>
  <style>
    :root{
      --bg:#0b1016; --panel:#111924; --muted:#9fb0c2; --text:#e8f0fb; --accent:#48c78e; --accent2:#1a73e8; --danger:#ff6b6b;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:15px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .app{display:grid;grid-template-columns:390px 1fr;min-height:100vh}
    .left{background:var(--panel);padding:16px;overflow:auto;border-right:1px solid #1b2532}
    .right{position:relative}
    h1{margin:0 0 10px;font-size:18px;letter-spacing:.2px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin:10px 0 12px}
    label{font-size:12px;color:var(--muted)}
    input[type="text"], input[type="number"], select{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #203044;background:#0e1520;color:var(--text)}
    input[type="checkbox"]{transform:scale(1.1)}
    .btn{padding:10px 12px;border-radius:10px;border:1px solid #2a3a4f;background:#162233;color:#fff;cursor:pointer}
    .btn:hover{filter:brightness(1.1)}
    .btn.primary{background:var(--accent2);border-color:#1e5fbc}
    .btn.success{background:var(--accent);border-color:#2da373}
    .btn.ghost{background:#101827;border-color:#243244}
    .section{padding:10px 0;border-top:1px solid #1b2532;margin-top:10px}
    .lane{background:#0e1520;border:1px solid #233247;border-radius:12px;padding:10px;margin:8px 0}
    .lane.dragging{opacity:.6;outline:2px dashed #2a3a4f}
    .lane > .row{margin:8px 0}
    .lane h3{margin:0;font-size:14px;color:#cfe2f7}
    .lane small{color:var(--muted)}
    .iconbtn{background:transparent;border:1px solid #34465f;border-radius:8px;color:#a3b6ce;padding:6px 8px;cursor:pointer}
    .iconbtn:hover{background:#182334}
    #map{
  position:relative;   /* no absolute positioning */
  width:100%;
  height:50vh;         /* half the viewport height */
}
    table{width:100%;border-collapse:collapse;margin-top:10px}
    th,td{padding:8px;border-bottom:1px solid #223045;text-align:right}
    th{color:#c3d4e9;font-weight:600}
    td:first-child, th:first-child{text-align:left}
    tfoot td{font-weight:700}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 8px;border:1px solid #2a3a4f;border-radius:999px}
    .muted{color:var(--muted)}
    .note{font-size:12px;color:var(--muted);margin-top:8px}
    .tag{font-size:11px;background:#0b1320;border:1px solid #22334a;border-radius:999px;padding:2px 6px;color:#cfe2f7}
    .legend{display:flex;gap:8px;align-items:center}
    .swatch{width:18px;height:3px;border-radius:2px}
  </style>
</head>
<body>
  <div class="app">
    <aside class="left">
      <h1>FarmPro • Multi-Lane Map & RPM Calculator</h1>
      <div class="row legend">
        <span class="tag">Legend</span>
        <span class="swatch" style="background:#1a73e8"></span><span class="muted">Loaded</span>
        <span class="swatch" style="background:linear-gradient(90deg,#808080 33%,transparent 33%,transparent 66%,#808080 66%)"></span><span class="muted">Deadhead</span>
      </div>

      <div class="section">
        <div class="row" style="gap:8px">
          <div style="flex:1 1 100%">
            <label>Base / Yard (optional)</label>
            <input id="base" type="text" placeholder="e.g., Fairbank, IA" />
          </div>
          <div style="flex:1 1 100%">
            <label>RPM uses</label>
            <select id="rpmMode">
              <option value="loaded">Loaded miles only</option>
              <option value="all">All miles (loaded + allocated deadhead)</option>
            </select>
          </div>
        </div>
        <div class="row">
          <label class="pill"><input id="includeStartDH" type="checkbox" checked> Include deadhead from Base → first Origin</label>
          <label class="pill"><input id="returnToBase" type="checkbox"> Add final deadhead from last Destination → Base</label>
        </div>
        <div class="controls">
          <button type="button" class="btn success" id="addLane">+ Add lane</button>
          <button type="button" class="btn primary" id="calc">Calculate & Map</button>
          <button type="button" class="btn ghost" id="optimize">Optimize Order (min deadhead)</button>
          <button type="button" class="btn ghost" id="sample">Load sample</button>
          <button type="button" class="btn" id="clearAll">Clear</button>
        </div>
      </div>

      <div id="lanes"></div>

      <div class="section">
        <div class="row" style="justify-content:space-between;align-items:center">
          <div><span class="tag">Results</span></div>
          <div class="row">
            <button type="button" class="btn" id="exportCsv">Export CSV</button>
            <button type="button" class="btn" id="emailBtn">Open Proposal</button>
          </div>
        </div>
        <table id="resultsTable" hidden>
          <thead>
            <tr>
              <th>Lane</th>
              <th>Origin → Destination</th>
              <th>Loaded mi</th>
              <th>Deadhead mi</th>
              <th>Input $/ton</th>
              <th>Input RPM</th>
              <th>Tons</th>
              <th>Bushels</th>
              <th>Gross $</th>
              <th>Lane RPM</th>
              <th>$ / ton</th>
              <th>$ / bu</th>
            </tr>
          </thead>
          <tbody></tbody>
          <tfoot>
            <tr>
              <td colspan="2">Totals</td>
              <td id="tLoaded"></td>
              <td id="tDeadhead"></td>
              <td></td><td></td>
              <td id="tTons"></td>
              <td id="tBushels"></td>
              <td id="tGross"></td>
              <td id="tRPM"></td>
              <td></td><td></td>
            </tr>
          </tfoot>
        </table>
        <div class="note">Overall RPM = Total Gross ÷ (Loaded + Deadhead). Also shown on the proposal page with a loaded-only RPM.</div>
      </div>
    </aside>

    <main class="right">
      <div id="map"></div>
    </main>
  </div>

  <template id="laneTmpl">
    <div class="lane" draggable="true">
      <div class="row" style="justify-content:space-between;align-items:center">
        <h3>Lane <span class="laneIndex"></span> <small class="muted">(Origin → Destination)</small></h3>
        <div class="row">
          <button type="button" class="iconbtn moveUp" title="Move up">▲</button>
          <button type="button" class="iconbtn moveDown" title="Move down">▼</button>
          <button type="button" class="iconbtn del" title="Remove lane">Remove</button>
        </div>
      </div>
      <div class="row">
        <div style="flex:1">
          <label>Origin</label>
          <input type="text" class="origin" placeholder="City, ST or full address" />
        </div>
        <div style="flex:1">
          <label>Destination</label>
          <input type="text" class="destination" placeholder="City, ST or full address" />
        </div>
      </div>
      <div class="row">
        <div style="flex:1">
          <label>Rate ($/ton)</label>
          <input type="number" class="rate" placeholder="e.g., 19" step="0.01" />
        </div>
        <div style="flex:1">
          <label>Tons</label>
          <input type="number" class="tons" placeholder="e.g., 26" step="0.1" />
        </div>
      </div>
      <div class="row">
        <div style="flex:1">
          <label>RPM ($/mi)</label>
          <input type="number" class="rpm" placeholder="e.g., 3.25" step="0.01" />
        </div>
        <div style="flex:1">
          <label>Bushels (optional)</label>
          <input type="number" class="bushels" placeholder="e.g., 950" step="1" />
        </div>
      </div>
    </div>
  </template>

  <script>
    let map, bounds, dirService;
    const polylines = [];
    let lastCompute = null;

    const $$ = (sel, ctx=document) => Array.from(ctx.querySelectorAll(sel));
    const $  = (sel, ctx=document) => ctx.querySelector(sel);
    const metersToMiles = m => m / 1609.344;
    const fmtMi    = n => (Math.round(n * 10) / 10).toLocaleString(undefined,{minimumFractionDigits:1, maximumFractionDigits:1});
    const fmtMoney = n => n.toLocaleString(undefined,{style:'currency',currency:'USD'});

    // ---- Diagnostics (handy on iPad) ----
    (function(){
      const box = document.createElement('div');
      box.id = 'fp_log';
      Object.assign(box.style,{
        position:'fixed',left:'8px',right:'8px',bottom:'8px',maxHeight:'40vh',
        overflow:'auto',font:'12px/1.35 system-ui,Segoe UI,Roboto,Arial',color:'#e8f0fb',
        background:'#111924',border:'1px solid #2a3a4f',borderRadius:'8px',
        padding:'8px',zIndex:2147483647,display:'none'
      });
      const btn = document.createElement('button');
      btn.textContent = 'Diagnostics';
      Object.assign(btn.style,{
        position:'fixed',right:'8px',top:'8px',zIndex:2147483647,
        background:'#1a73e8',color:'#fff',border:'1px solid #0d4fb6',
        borderRadius:'8px',padding:'6px 10px',font:'13px system-ui'
      });
      btn.onclick = ()=>{ box.style.display = (box.style.display==='none'?'block':'none'); };
      document.addEventListener('DOMContentLoaded',()=>{ document.body.appendChild(btn); document.body.appendChild(box); });
      function logLine(kind, msg){
        const p=document.createElement('div'); p.textContent = `[${kind}] ${msg}`;
        box.appendChild(p); box.style.display='block';
      }
      window.fpLog = (msg)=>logLine('log', msg);
      window.addEventListener('error', e => logLine('error', (e.error && e.error.stack) || e.message || String(e)));
      window.addEventListener('unhandledrejection', e => logLine('promise', (e.reason && (e.reason.stack||e.reason.message)) || String(e.reason)));
    })();

    function toast(msg, ms=3000){
      let el = document.getElementById('fp_toast');
      if(!el){
        el = document.createElement('div');
        el.id = 'fp_toast';
        Object.assign(el.style, {
          position:'fixed', left:'50%', bottom:'16px', transform:'translateX(-50%)',
          background:'#111924', color:'#e8f0fb', padding:'8px 12px',
          border:'1px solid #2a3a4f', borderRadius:'10px', zIndex:99999,
          boxShadow:'0 6px 18px rgba(0,0,0,.35)', font:'13px/1.3 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif',
          transition:'opacity .25s', opacity:'1'
        });
        document.body.appendChild(el);
      }
      el.textContent = msg;
      el.style.opacity = '1';
      clearTimeout(el._t);
      el._t = setTimeout(()=>{ el.style.opacity='0'; }, ms);
    }

    document.addEventListener('DOMContentLoaded', setupUI);

    function setupUI(){
      $('#addLane').addEventListener('click', ()=>addLane());
      $('#calc').addEventListener('click', calculateAndMap);
      $('#optimize').addEventListener('click', optimizeOrder);
      $('#sample').addEventListener('click', loadSample);
      $('#clearAll').addEventListener('click', clearAll);
      $('#exportCsv').addEventListener('click', exportCSV);
      $('#emailBtn').addEventListener('click', openProposal);
      $('#rpmMode').addEventListener('change', ()=>{ persist(); });

      const wrap = $('#lanes');
      wrap.addEventListener('dragover', e=>{
        e.preventDefault();
        const dragging = document.querySelector('.lane.dragging');
        if(!dragging) return;
        const siblings = [...wrap.querySelectorAll('.lane:not(.dragging)')];
        const next = siblings.find(sib => e.clientY <= sib.getBoundingClientRect().top + sib.offsetHeight/2);
        wrap.insertBefore(dragging, next || null);
      });

      if(!loadFromURL()) loadFromStorage();
      if(!$('#lanes').children.length) addLane();
    }

    function safeAutocomplete(input){
      try{
        if (google?.maps?.places?.Autocomplete) {
          new google.maps.places.Autocomplete(input, { fields:['geometry','name'], types:['geocode'] });
        }
      } catch(_){}
    }

    function initMap(){
      try{
        map = new google.maps.Map(document.getElementById('map'), {
          center:{lat:41.878, lng:-93.097}, zoom:6, mapId:'fde12c0d9b0a8c86'
        });
        bounds = new google.maps.LatLngBounds();
        dirService = new google.maps.DirectionsService();
        window._fpDM = new google.maps.DistanceMatrixService();
        safeAutocomplete($('#base'));
      }catch(e){
        console.warn('Maps init failed:', e);
      }
    }

    function addLane(data={}){
      const wrap = $('#lanes');
      const tmpl = $('#laneTmpl');
      const node = tmpl.content.firstElementChild.cloneNode(true);
      wrap.appendChild(node);
      refreshLaneIndices();

      const o = node.querySelector('.origin');
      const d = node.querySelector('.destination');
      safeAutocomplete(o); safeAutocomplete(d);

      if(data.origin) o.value = data.origin;
      if(data.destination) d.value = data.destination;
      if(data.rate!=null) node.querySelector('.rate').value = data.rate;
      if(data.tons!=null) node.querySelector('.tons').value = data.tons;
      if(data.rpm!=null) node.querySelector('.rpm').value = data.rpm;
      if(data.bushels!=null) node.querySelector('.bushels').value = data.bushels;

      node.querySelector('.del').addEventListener('click', ()=>{
        node.remove(); refreshLaneIndices(); persist();
      });
      node.querySelector('.moveUp').addEventListener('click', ()=> moveLane(node,-1));
      node.querySelector('.moveDown').addEventListener('click', ()=> moveLane(node,+1));

      $$('.origin,.destination,.rate,.tons,.rpm,.bushels', node).forEach(inp=>{
        inp.addEventListener('change', persist);
        inp.addEventListener('blur', persist);
      });
      persist();
    }

    function moveLane(node, dir){
      const wrap = $('#lanes');
      const lanes = $$('#lanes .lane');
      const idx = lanes.indexOf(node);
      const newIdx = idx + dir;
      if(newIdx < 0 || newIdx >= lanes.length) return;
      if(dir < 0){
        wrap.insertBefore(node, lanes[newIdx]);
      } else {
        wrap.insertBefore(node, lanes[newIdx].nextSibling);
      }
      refreshLaneIndices(); persist();
    }

    function refreshLaneIndices(){
      $$('#lanes .lane').forEach((lane, i)=>{
        lane.querySelector('.laneIndex').textContent = i+1;
      });
    }

    function clearMap(){
      polylines.forEach(p=>p.setMap && p.setMap(null));
      polylines.length = 0;
      bounds = new google.maps.LatLngBounds();
    }

    async function routeMiles(origin, destination){
      return new Promise((resolve, reject)=>{
        if(!dirService){ reject(new Error('Map not initialized')); return; }
        dirService.route({ origin, destination, travelMode:'DRIVING', region:'US' },
          (res, status)=>{
            if(status === 'OK'){
              const leg = res.routes[0].legs[0];
              const path = res.routes[0].overview_path;
              resolve({ miles: metersToMiles(leg.distance.value), path });
            } else {
              reject(new Error(status+': '+origin+' → '+destination));
            }
          }
        );
      });
    }

    function drawPath(path, {color='#1a73e8', weight=4, dash=false}={}){
      if(!map) return;
      const polyline = new google.maps.Polyline({
        map, path, strokeColor: color, strokeOpacity: 1, strokeWeight: weight,
        icons: dash ? [{icon:{path:'M 0,-1 0,1', strokeOpacity:1, scale:2}, offset:'0', repeat:'22px'}] : undefined
      });
      polylines.push(polyline);
      path.forEach(ll=>bounds.extend(ll));
      map.fitBounds(bounds, {top:24,right:24,bottom:24,left:24});
    }

    // ---------- Optimizer (unchanged) ----------
    const _deadheadCache = new Map();  // key: "A|B" -> miles
    async function deadheadMiles(a, b){
      const key = a+'|'+b;
      if(_deadheadCache.has(key)) return _deadheadCache.get(key);
      let miles = await new Promise((resolve)=>{
        const dm = window._fpDM;
        if(!dm){ resolve(Infinity); return; }
        dm.getDistanceMatrix(
          {origins:[a], destinations:[b], travelMode:'DRIVING', region:'US', unitSystem:google.maps.UnitSystem.IMPERIAL},
          (res, status)=>{
            if(status==='OK' && res?.rows?.[0]?.elements?.[0]?.status==='OK'){
              resolve(res.rows[0].elements[0].distance.value / 1609.344);
            } else {
              resolve(Infinity);
            }
          }
        );
      });
      if(!isFinite(miles)){
        try{
          const r = await routeMiles(a, b);
          miles = r.miles;
          await new Promise(r=>setTimeout(r, 75));
        }catch{
          miles = Infinity;
        }
      }
      _deadheadCache.set(key, miles);
      return miles;
    }

    async function buildDeadheadMatrix(lanes, base, includeStart, returnTo){
      const n = lanes.length;
      const M = Array.from({length:n},()=>Array(n).fill(Infinity));
      for(let i=0;i<n;i++){
        for(let j=0;j<n;j++){
          if(i===j) continue;
          M[i][j] = await deadheadMiles(lanes[i].destination, lanes[j].origin);
        }
      }
      const baseTo = Array(n).fill(Infinity);
      const toBase = Array(n).fill(Infinity);
      if(base && includeStart){
        for(let j=0;j<n;j++) baseTo[j] = await deadheadMiles(base, lanes[j].origin);
      }
      if(base && returnTo){
        for(let i=0;i<n;i++) toBase[i] = await deadheadMiles(lanes[i].destination, base);
      }
      return {M, baseTo, toBase};
    }

    function* permutations(arr){
      const a = arr.slice();
      const c = Array(a.length).fill(0);
      yield a.slice();
      let i = 0;
      while(i < a.length){
        if(c[i] < i){
          if(i % 2 === 0){ [a[0], a[i]] = [a[i], a[0]]; }
          else { [a[c[i]], a[i]] = [a[i], a[c[i]]]; }
          yield a.slice();
          c[i]++; i = 0;
        } else {
          c[i] = 0; i++;
        }
      }
    }

    function costOfOrder(order, M, baseTo, toBase){
      let dead=0;
      if(baseTo?.length){
        const first = baseTo[order[0]];
        if(!isFinite(first)) return Infinity;
        dead += first;
      }
      for(let k=0;k<order.length-1;k++){
        const c = M[order[k]][order[k+1]];
        if(!isFinite(c)) return Infinity;
        dead += c;
      }
      if(toBase?.length){
        const back = toBase[order[order.length-1]];
        if(!isFinite(back)) return Infinity;
        dead += back;
      }
      return dead;
    }

    async function optimizeOrder(){
      const lanes = readLanes();
      if(lanes.length < 2){ toast('Add at least two lanes to optimize'); return; }
      const base = $('#base').value.trim();
      const includeStart = $('#includeStartDH').checked && !!base;
      const returnTo     = $('#returnToBase').checked && !!base;
      toast('Computing best order…');
      try{
        const {M, baseTo, toBase} = await buildDeadheadMatrix(lanes, base, includeStart, returnTo);
        const n = lanes.length;
        let bestOrder = [...Array(n).keys()];
        let bestCost  = Infinity;
        if(n <= 7){
          for(const ord of permutations(bestOrder)){
            const c = costOfOrder(ord, M, includeStart?baseTo:[], returnTo?toBase:[]);
            if(c < bestCost){ bestCost = c; bestOrder = ord.slice(); }
          }
        } else {
          let start = 0;
          if(includeStart){
            let min = Infinity;
            for(let j=0;j<n;j++){ if(baseTo[j] < min){ min = baseTo[j]; start = j; } }
          } else {
            let bestAvg = Infinity;
            for(let i=0;i<n;i++){
              const vals = M[i].filter(v=>isFinite(v));
              const avg = vals.length ? vals.reduce((a,b)=>a+b,0)/vals.length : Infinity;
              if(avg < bestAvg){ bestAvg = avg; start = i; }
            }
          }
          const used = Array(n).fill(false); used[start]=true;
          const ord = [start];
          for(let step=1; step<n; step++){
            const i = ord[ord.length-1];
            let bestJ=-1, best=Infinity;
            for(let j=0;j<n;j++){
              if(used[j]) continue;
              const c = M[i][j];
              if(c < best){ best=c; bestJ=j; }
            }
            if(bestJ === -1){ bestJ = used.indexOf(false); }
            used[bestJ] = true; ord.push(bestJ);
          }
          bestOrder = ord;
          bestCost = costOfOrder(ord, M, includeStart?baseTo:[], returnTo?toBase:[]);
        }
        if(!isFinite(bestCost)){
          toast('Could not compute a valid order. Check addresses and try again.');
          return;
        }
        const wrap  = $('#lanes');
        const nodes = Array.from($('#lanes').querySelectorAll('.lane'));
        bestOrder.map(i => nodes[i]).forEach(n => wrap.appendChild(n));
        refreshLaneIndices(); persist();
        toast(`Order optimized. Est. deadhead: ${fmtMi(bestCost)} mi`);
        await calculateAndMap();
      }catch(err){
        console.warn('optimizeOrder error:', err);
        alert('Could not optimize (API limits or address errors). Try again.');
      }
    }
    // ---------- end optimizer ----------

    async function calculateAndMap(){
      const lanes = readLanes();
      if(lanes.length===0){ alert('Add at least one lane'); return; }
      if(!dirService){ alert('Map not ready yet.'); return; }

      clearMap();

      const base = $('#base').value.trim();
      const includeStartDH = $('#includeStartDH').checked && base;
      const returnToBase   = $('#returnToBase').checked && base;
      const rpmMode        = $('#rpmMode').value; // 'loaded' | 'all'

      let totals = { loaded:0, deadhead:0, gross:0, tons:0, bushels:0 };
      const perLane = [];
      let prevDest = null;

      // optional deadhead: Base -> first origin
      if(includeStartDH){
        try{
          const {miles, path} = await routeMiles(base, lanes[0].origin);
          totals.deadhead += miles;
          drawPath(path, {color:'#808080', weight:4, dash:true});
          prevDest = lanes[0].origin;
        }catch(e){
          console.warn('Start DH failed:', e); toast('Could not route Base → first origin (continuing)');
          prevDest = lanes[0].origin;
        }
      }

      // Iterate lanes (draw loaded, draw DH between lanes for visuals; allocate DH later to lanes)
      for(let i=0;i<lanes.length;i++){
        const L = lanes[i];

        if(i>0 || (!includeStartDH && i===0 && prevDest)){
          const from = perLane.length ? perLane[perLane.length-1].destination : prevDest;
          if(from){
            try{
              const {miles, path} = await routeMiles(from, L.origin);
              totals.deadhead += miles; drawPath(path, {color:'#808080', weight:4, dash:true});
            }catch(e){
              console.warn(`DH ${from} → ${L.origin} failed:`, e);
              toast(`Could not route deadhead to ${L.origin} (continuing)`);
            }
          }
        }

        try{
          const {miles, path} = await routeMiles(L.origin, L.destination);
          totals.loaded += miles; drawPath(path, {color:'#1a73e8', weight:5});
          perLane.push({
            index:i+1,
            origin:L.origin, destination:L.destination,
            loaded:miles, deadhead:0,
            rate:Number(L.rate)||0,
            tons:isFinite(L.tons)?Number(L.tons):NaN,
            rpm:isFinite(L.rpm)?Number(L.rpm):NaN,
            bushels:isFinite(L.bushels)?Number(L.bushels):NaN,
            gross:0 // fill after DH allocation + rule
          });
        }catch(e){
          console.warn(`Loaded ${L.origin} → ${L.destination} failed:`, e);
          toast(`Could not route ${L.origin} → ${L.destination} (counting as 0 mi)`);
          perLane.push({
            index:i+1,
            origin:L.origin, destination:L.destination,
            loaded:0, deadhead:0,
            rate:Number(L.rate)||0,
            tons:isFinite(L.tons)?Number(L.tons):NaN,
            rpm:isFinite(L.rpm)?Number(L.rpm):NaN,
            bushels:isFinite(L.bushels)?Number(L.bushels):NaN,
            gross:0
          });
        }
      }

      // Allocate numeric deadhead to lanes (so RPM 'all miles' can include it)
      perLane.forEach(pl=>pl.deadhead=0);
      const dhPairs=[];
      if(includeStartDH && perLane[0]) dhPairs.push([base, perLane[0].origin, 0]);
      for(let i=1;i<perLane.length;i++) dhPairs.push([perLane[i-1].destination, perLane[i].origin, i]);

      const dhPromises = dhPairs.map(([a,b,idx]) =>
        routeMiles(a,b).then(r=>({idx,miles:r.miles})).catch(_=>({idx,miles:0}))
      );
      const dhRes = await Promise.all(dhPromises);
      dhRes.forEach(({idx,miles})=>{ if(idx>=0 && perLane[idx]) perLane[idx].deadhead += miles; });

      // final deadhead back to base
      let finalDhMiles = 0;
      if(returnToBase && perLane.length){
        try{
          const last = perLane[perLane.length-1];
          const {miles, path} = await routeMiles(last.destination, base);
          finalDhMiles = miles; totals.deadhead += miles; drawPath(path, {color:'#808080', weight:4, dash:true});
        }catch(e){
          console.warn('Return-to-base failed:', e);
          toast('Could not route final deadhead back to Base (continuing)');
        }
      }

      // Now compute gross per lane based on priority (RPM first, then $/ton×tons)
      perLane.forEach(L=>{
        const hasRPM = isFinite(L.rpm) && L.rpm>0;
        const hasRateTons = isFinite(L.rate) && L.rate>0 && isFinite(L.tons) && L.tons>0;

        const milesForRPM = (rpmMode === 'all') ? (L.loaded + L.deadhead) : L.loaded;
        const grossFromRPM = hasRPM ? L.rpm * milesForRPM : 0;
        const grossFromTons = hasRateTons ? L.rate * L.tons : 0;

        L.gross = hasRPM ? grossFromRPM : grossFromTons;

        // Totals
        if(isFinite(L.tons)) totals.tons += (L.tons||0);
        if(isFinite(L.bushels)) totals.bushels += (L.bushels||0);
        totals.gross += (L.gross||0);
      });

      lastCompute = { perLane, totals, finalDhMiles, base, includeStartDH, returnToBase, url: location.href, rpmMode };
      renderResults(perLane, totals, { finalDhMiles, rpmMode });
      persist();
      updateShareURL();
    }

    function readLanes(){
      const list = [];
      $$('#lanes .lane').forEach(el=>{
        const origin = el.querySelector('.origin').value.trim();
        const destination = el.querySelector('.destination').value.trim();
        const rate = parseFloat(el.querySelector('.rate').value);
        const tons = parseFloat(el.querySelector('.tons').value);
        const rpm = parseFloat(el.querySelector('.rpm').value);
        const bushels = parseFloat(el.querySelector('.bushels').value);
        if(origin && destination){ list.push({origin, destination, rate, tons, rpm, bushels}); }
      });
      return list;
    }

    function renderResults(perLane, totals, opts={}){
      const { finalDhMiles=0, rpmMode='loaded' } = opts;
      const table = $('#resultsTable');
      const tbody = table.querySelector('tbody');
      tbody.innerHTML = '';

      let loaded = 0, deadhead = 0, gross = 0, sumTons=0, sumBushels=0;
      perLane.forEach(L=>{ loaded += L.loaded; deadhead += L.deadhead; gross += L.gross; sumTons += (isFinite(L.tons)?(L.tons||0):0); sumBushels += (isFinite(L.bushels)?(L.bushels||0):0); });
      deadhead += finalDhMiles;

      perLane.forEach(L=>{
        const laneMilesAll = (L.loaded + L.deadhead);
        const laneRPM = L.gross / (laneMilesAll || 1);
        const ratePerTon = (isFinite(L.tons) && L.tons>0) ? (L.gross / L.tons) : NaN;
        const ratePerBu  = (isFinite(L.bushels) && L.bushels>0) ? (L.gross / L.bushels) : NaN;

        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${L.index}</td>
          <td style="text-align:left">${escapeHtml(L.origin)} → ${escapeHtml(L.destination)}</td>
          <td>${fmtMi(L.loaded)}</td>
          <td>${fmtMi(L.deadhead)}</td>
          <td>${(isFinite(L.rate)&&L.rate>0)?Number(L.rate).toFixed(2):''}</td>
          <td>${(isFinite(L.rpm)&&L.rpm>0)?Number(L.rpm).toFixed(2):''}</td>
          <td>${(isFinite(L.tons)&&L.tons>0)?Number(L.tons).toFixed(1):''}</td>
          <td>${(isFinite(L.bushels)&&L.bushels>0)?Number(L.bushels):''}</td>
          <td>${fmtMoney(L.gross||0)}</td>
          <td>${laneRPM?laneRPM.toFixed(2):''}</td>
          <td>${isFinite(ratePerTon)?ratePerTon.toFixed(2):''}</td>
          <td>${isFinite(ratePerBu)?ratePerBu.toFixed(2):''}</td>
        `;
        tbody.appendChild(tr);
      });

      $('#tLoaded').textContent = fmtMi(loaded);
      $('#tDeadhead').textContent = fmtMi(deadhead);
      $('#tGross').textContent = fmtMoney(gross);
      $('#tTons').textContent = (sumTons>0)?sumTons.toFixed(1):'';
      $('#tBushels').textContent = (sumBushels>0)?sumBushels.toFixed(0):'';
      const totalMiles = loaded + deadhead;
      const rpmAll = gross / (totalMiles || 1);
      $('#tRPM').textContent = rpmAll.toFixed(2);
      table.hidden = false;

      const note = document.querySelector('.note');
      const rpmNote = (rpmMode==='all') ? 'RPM uses ALL miles (loaded + allocated deadhead).' : 'RPM uses LOADED miles only.';
      if(finalDhMiles>0){
        note.textContent = `Overall RPM = Total Gross ÷ (Loaded + Deadhead). ${rpmNote} Includes ${fmtMi(finalDhMiles)} mi return-to-base deadhead.`;
      } else {
        note.textContent = `Overall RPM = Total Gross ÷ (Loaded + Deadhead). ${rpmNote}`;
      }
    }

    function exportCSV(){
      const perLane = collectPerLaneFromTable();
      if(!perLane.length){ alert('No results yet. Click Calculate & Map first.'); return; }
      const headers = ['Lane','Origin','Destination','Loaded_mi','Deadhead_mi','Input_rate_per_ton','Input_RPM','Tons','Bushels','Gross','Lane_RPM','Rate_per_ton','Rate_per_bu'];
      const rows = perLane.map(L=>[
        L.index,
        '"'+L.origin.replaceAll('"','""')+'"',
        '"'+L.destination.replaceAll('"','""')+'"',
        L.loaded.toFixed(1),
        L.deadhead.toFixed(1),
        (isFinite(L.rate)?L.rate.toFixed(2):''),
        (isFinite(L.rpm)?L.rpm.toFixed(2):''),
        (isFinite(L.tons)?L.tons.toFixed(1):''),
        (isFinite(L.bushels)?Math.round(L.bushels):''),
        (L.gross||0).toFixed(2),
        (L.gross / (L.loaded+L.deadhead||1)).toFixed(2),
        (isFinite(L.ratePerTon)?L.ratePerTon.toFixed(2):''),
        (isFinite(L.ratePerBu)?L.ratePerBu.toFixed(2):'')
      ]);
      const csv = [headers.join(','), ...rows.map(r=>r.join(','))].join('\n');
      const blob = new Blob([csv],{type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = Object.assign(document.createElement('a'), {href:url, download:'lanes_export.csv'});
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }

    function openProposal(){
      if(!lastCompute){ alert('Calculate first, then open the proposal.'); return; }
      const { perLane, finalDhMiles, base, includeStartDH, returnToBase, url, rpmMode } = lastCompute;

      let loaded=0, deadhead=0, gross=0, sumTons=0, sumBushels=0;
      perLane.forEach(L=>{ loaded+=L.loaded; deadhead+=L.deadhead; gross+=L.gross; sumTons+=(isFinite(L.tons)?(L.tons||0):0); sumBushels+=(isFinite(L.bushels)?(L.bushels||0):0); });
      deadhead += finalDhMiles;
      const rpmAll = gross / (loaded + deadhead || 1);
      const rpmLoaded = gross / (loaded || 1);

      const flags = [];
      if(includeStartDH && base) flags.push('Base→first origin DH included');
      if(returnToBase && base)   flags.push('Final DH back to Base included');
      flags.push(rpmMode==='all' ? 'RPM uses ALL miles' : 'RPM uses LOADED miles only');

      const esc = s => (s??'').toString().replace(/[&<>]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;"}[c]));

      const rowsHtml = perLane.map(L=>{
        const laneRPM = L.gross / (L.loaded+L.deadhead||1);
        const rpt = (isFinite(L.tons)&&L.tons>0) ? (L.gross/L.tons) : NaN;
        const rpb = (isFinite(L.bushels)&&L.bushels>0) ? (L.gross/L.bushels) : NaN;
        return `<tr>
          <td style="text-align:center">${L.index}</td>
          <td>${esc(L.origin)} → ${esc(L.destination)}</td>
          <td style="text-align:right">${fmtMi(L.loaded)}</td>
          <td style="text-align:right">${fmtMi(L.deadhead)}</td>
          <td style="text-align:right">${(isFinite(L.rate)&&L.rate>0)?L.rate.toFixed(2):''}</td>
          <td style="text-align:right">${(isFinite(L.rpm)&&L.rpm>0)?L.rpm.toFixed(2):''}</td>
          <td style="text-align:right">${(isFinite(L.tons)&&L.tons>0)?L.tons.toFixed(1):''}</td>
          <td style="text-align:right">${(isFinite(L.bushels)&&L.bushels>0)?Math.round(L.bushels):''}</td>
          <td style="text-align:right">${fmtMoney(L.gross||0)}</td>
          <td style="text-align:right">${laneRPM?laneRPM.toFixed(2):''}</td>
          <td style="text-align:right">${isFinite(rpt)?rpt.toFixed(2):''}</td>
          <td style="text-align:right">${isFinite(rpb)?rpb.toFixed(2):''}</td>
        </tr>`;
      }).join('');

      const html = `<!doctype html>
<html><head><meta charset="utf-8" />
  <title>Lane Proposal – FarmPro</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{font:14px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:#0b1320;margin:24px}
    h1{margin:0 0 6px;font-size:20px}
    .muted{color:#586278}
    .actions{margin:12px 0;display:flex;gap:8px;flex-wrap:wrap}
    button{padding:8px 10px;border-radius:8px;border:1px solid #c8d1e0;background:#0d63ff;color:#fff;cursor:pointer}
    button.secondary{background:#fff;color:#0b1320;border-color:#c8d1e0}
    a.button{display:inline-block;text-decoration:none}
    table{width:100%;border-collapse:collapse;margin-top:12px}
    th,td{padding:8px;border-bottom:1px solid #e5e9f2}
    th{text-align:right;background:#f6f8fc}
    th:first-child,td:first-child{text-align:center}
    th:nth-child(2),td:nth-child(2){text-align:left}
    tfoot td{font-weight:700}
    pre{white-space:pre-wrap;background:#f6f8fc;border:1px solid #e5e9f2;border-radius:8px;padding:10px;margin-top:12px}
  </style>
</head>
<body>
  <h1>Proposed Lanes Summary</h1>
  ${base?`<div class="muted">Base/Yard: ${esc(base)}</div>`:''}
  ${flags.length?`<div class="muted">Notes: ${esc(flags.join('; '))}</div>`:''}
  <div class="actions">
    <button id="copy">Copy Plain Text</button>
    <button id="print" class="secondary">Print / Save PDF</button>
    <a class="button" href="${esc(url)}" target="_blank" rel="noopener"><button class="secondary">Open Calculator</button></a>
  </div>
  <table>
    <thead>
      <tr>
        <th>#</th><th>Origin → Destination</th><th>Loaded mi</th><th>Deadhead mi</th>
        <th>$ / ton (in)</th><th>RPM (in)</th><th>Tons</th><th>Bushels</th><th>Gross</th><th>Lane RPM</th><th>$ / ton</th><th>$ / bu</th>
      </tr>
    </thead>
    <tbody>${rowsHtml}</tbody>
    <tfoot>
      <tr>
        <td colspan="2">Totals</td>
        <td style="text-align:right">${fmtMi(loaded)}</td>
        <td style="text-align:right">${fmtMi(deadhead)}</td>
        <td></td><td></td>
        <td style="text-align:right">${sumTons?sumTons.toFixed(1):''}</td>
        <td style="text-align:right">${sumBushels?sumBushels.toFixed(0):''}</td>
        <td style="text-align:right">${fmtMoney(gross)}</td>
        <td style="text-align:right">${(gross/(loaded+deadhead||1)).toFixed(2)}</td>
        <td></td><td></td>
      </tr>
    </tfoot>
  </table>
  <div style="margin-top:10px">Overall RPM (all miles): <b>$${(gross/(loaded+deadhead||1)).toFixed(2)}</b> — Loaded-only RPM: <b>$${(gross/(loaded||1)).toFixed(2)}</b></div>
  <pre id="plain">${esc(buildPlainText(perLane, {base, flags, loaded, deadhead, gross, url}))}</pre>
  <script>
    function buildPlainText(perLane, ctx){
      const {base, flags, loaded, deadhead, gross, url} = ctx;
      const lines=[];
      lines.push('Proposed Lanes Summary');
      if(base) lines.push('Base/Yard: '+base);
      if(flags?.length) lines.push('Notes: '+flags.join('; '));
      lines.push('');
      perLane.forEach(L=>{
        const laneRPM = L.gross / (L.loaded+L.deadhead||1);
        const rpt = (isFinite(L.tons)&&L.tons>0)?(L.gross/L.tons):NaN;
        const rpb = (isFinite(L.bushels)&&L.bushels>0)?(L.gross/L.bushels):NaN;
        lines.push(\`Lane \${L.index}: \${L.origin} → \${L.destination}\`);
        lines.push(\`  Loaded: \${(\`${fmtMi(0)}\` && (Math.round(L.loaded*10)/10).toLocaleString(undefined,{minimumFractionDigits:1,maximumFractionDigits:1}))} mi | Deadhead: \${(Math.round(L.deadhead*10)/10).toLocaleString(undefined,{minimumFractionDigits:1,maximumFractionDigits:1})} mi\`);
        lines.push(\`  Inputs: \$\${isFinite(L.rate)&&L.rate>0?L.rate.toFixed(2):'-'}/ton | RPM \$\${isFinite(L.rpm)&&L.rpm>0?L.rpm.toFixed(2):'-'} | Tons \${isFinite(L.tons)&&L.tons>0?L.tons.toFixed(1):'-'} | Bushels \${isFinite(L.bushels)&&L.bushels>0?Math.round(L.bushels):'-'}\`);
        lines.push(\`  Gross: ${'${'}(L.gross||0).toLocaleString(undefined,{style:'currency',currency:'USD'})${'}'} | Lane RPM: \$\${laneRPM?laneRPM.toFixed(2):'-'} | \$/ton: \${isFinite(rpt)?rpt.toFixed(2):'-'} | \$/bu: \${isFinite(rpb)?rpb.toFixed(2):'-'}\`);
        lines.push('');
      });
      lines.push(\`TOTAL Loaded: \${(Math.round(loaded*10)/10).toLocaleString(undefined,{minimumFractionDigits:1,maximumFractionDigits:1})} mi\`);
      lines.push(\`TOTAL Deadhead: \${(Math.round(deadhead*10)/10).toLocaleString(undefined,{minimumFractionDigits:1,maximumFractionDigits:1})} mi\`);
      lines.push(\`TOTAL Miles: \${(Math.round((loaded+deadhead)*10)/10).toLocaleString(undefined,{minimumFractionDigits:1,maximumFractionDigits:1})} mi\`);
      lines.push(\`TOTAL Gross: ${'${'}gross.toLocaleString(undefined,{style:'currency',currency:'USD'})${'}'}\`);
      lines.push(\`Overall RPM (all miles): \$\${(gross/(loaded+deadhead||1)).toFixed(2)} | Loaded-only RPM: \$\${(gross/(loaded||1)).toFixed(2)}\`);
      lines.push('');
      lines.push('Open in calculator: '+url);
      return lines.join('\\n');
    }
    (function(){
      const copyBtn = document.getElementById('copy');
      const printBtn = document.getElementById('print');
      const textEl = document.getElementById('plain');
      copyBtn.addEventListener('click', ()=>{
        const text = textEl.textContent;
        if(navigator.clipboard?.writeText){
          navigator.clipboard.writeText(text).then(()=>alert('Copied to clipboard.'))
            .catch(()=>{
              const ta=document.createElement('textarea'); ta.value=text; document.body.appendChild(ta);
              ta.select(); document.execCommand('copy'); ta.remove(); alert('Copied to clipboard.');
            });
        } else {
          const ta=document.createElement('textarea'); ta.value=text; document.body.appendChild(ta);
          ta.select(); document.execCommand('copy'); ta.remove(); alert('Copied to clipboard.');
        }
      });
      printBtn.addEventListener('click', ()=>window.print());
    })();
  <\/script>
</body></html>`;

      const blob = new Blob([html], { type: 'text/html' });
      const blobUrl = URL.createObjectURL(blob);
      const w = window.open(blobUrl, '_blank', 'noopener');
      if(!w){
        const a = document.createElement('a');
        a.href = blobUrl; a.target = '_blank'; a.rel = 'noopener'; a.download = 'proposal.html';
        document.body.appendChild(a); a.click(); a.remove();
      }
      setTimeout(()=>URL.revokeObjectURL(blobUrl), 60000);
    }

    function collectPerLaneFromTable(){
      const rows = Array.from($('#resultsTable tbody').rows);
      if(!rows.length) return [];
      return rows.map(tr=>{
        const tds = tr.cells;
        const index = Number(tds[0].textContent);
        const pair = tds[1].textContent;
        const loaded = Number(tds[2].textContent.replace(/,/g,''));
        const deadhead = Number(tds[3].textContent.replace(/,/g,''));
        const rate = Number(tds[4].textContent);
        const rpm  = Number(tds[5].textContent);
        const tons = Number(tds[6].textContent);
        const bushels = Number(tds[7].textContent);
        const gross = Number(tds[8].textContent.replace(/[$,]/g,''));
        const [origin, destination] = pair.split(' → ').map(s=>s.trim());
        const laneRPM = gross / (loaded+deadhead || 1);
        const ratePerTon = (isFinite(tons)&&tons>0)?(gross/tons):NaN;
        const ratePerBu  = (isFinite(bushels)&&bushels>0)?(gross/bushels):NaN;
        return {index, origin, destination, loaded, deadhead, rate, rpm, tons, bushels, gross, laneRPM, ratePerTon, ratePerBu};
      });
    }

    function escapeHtml(str){ return str.replace(/[&<>"]/g, s=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[s])); }

    function persist(){
      const data = {
        base: $('#base').value.trim(),
        includeStartDH: $('#includeStartDH').checked,
        returnToBase: $('#returnToBase').checked,
        rpmMode: $('#rpmMode').value,
        lanes: readLanes()
      };
      localStorage.setItem('farmpro_lanes', JSON.stringify(data));
    }

    function loadFromStorage(){
      try{
        const raw = localStorage.getItem('farmpro_lanes');
        if(!raw) { addLane(); return true; }
        const data = JSON.parse(raw);
        $('#base').value = data.base||'';
        $('#includeStartDH').checked = !!data.includeStartDH;
        $('#returnToBase').checked = !!data.returnToBase;
        $('#rpmMode').value = data.rpmMode || 'loaded';
        $('#lanes').innerHTML='';
        (data.lanes||[]).forEach(addLane);
        if(!(data.lanes||[]).length) addLane();
        return true;
      }catch(e){ addLane(); return true; }
    }

    function updateShareURL(){
      const payload = {
        base: $('#base').value.trim(),
        i: $('#includeStartDH').checked?1:0,
        r: $('#returnToBase').checked?1:0,
        m: $('#rpmMode').value,
        lanes: readLanes()
      };
      const qp = new URLSearchParams({state: btoa(unescape(encodeURIComponent(JSON.stringify(payload))))});
      const url = location.origin + location.pathname + '?' + qp.toString();
      history.replaceState(null,'',url);
    }

    function loadFromURL(){
      const s = new URLSearchParams(location.search).get('state');
      if(!s) return false;
      try{
        const data = JSON.parse(decodeURIComponent(escape(atob(s))));
        $('#base').value = data.base||'';
        $('#includeStartDH').checked = !!data.i;
        $('#returnToBase').checked = !!data.r;
        $('#rpmMode').value = data.m || 'loaded';
        $('#lanes').innerHTML='';
        (data.lanes||[]).forEach(addLane);
        if(!(data.lanes||[]).length) addLane();
        return true;
      }catch(e){ return false; }
    }

    function loadSample(){
      $('#lanes').innerHTML='';
      addLane({origin:'Mankato, MN', destination:'Lake Mills, WI', rate:38, tons:26, rpm:3.10, bushels:900});
      addLane({origin:'Cambria, WI', destination:'Milwaukee, WI', rate:14, tons:26});
      addLane({origin:'Racine, WI', destination:'East Dubuque, IL', rpm:3.45, bushels:950});
      addLane({origin:'East Dubuque, IL', destination:'Stanhope, IA', rate:24, tons:26});
      $('#base').value = 'Fairbank, IA';
      $('#includeStartDH').checked = true;
      $('#returnToBase').checked = true;
      $('#rpmMode').value = 'all';
      persist();
    }

    function clearAll(){
      if(!confirm('Clear all lanes and settings?')) return;
      localStorage.removeItem('farmpro_lanes');
      $('#lanes').innerHTML='';
      $('#base').value='';
      $('#includeStartDH').checked = true;
      $('#returnToBase').checked = false;
      $('#rpmMode').value = 'loaded';
      addLane();
      history.replaceState(null,'',location.pathname);
      clearMap();
      $('#resultsTable').hidden = true;
      lastCompute = null;
    }
  </script>
  <!-- Your key kept as provided -->
  <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAX9GFUEGbzuUx3KefbZw9_a0_eDOiNFf0&libraries=places&callback=initMap"></script>
</body>
</html>
